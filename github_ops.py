# github_ops.py
"""
GitHub helper utilities for the LLM Code Deployment project.

Provides:
 - create_github_repo(repo_name)
 - push_directory_to_repo(local_dir, repo_full_name)
 - enable_pages(repo_full_name)    # robust: handles 409 and polls for html_url
 - clone_repo_to_tmp(repo_full_name, tmpdir)
 - update_repo_with_dir(clone_dir, source_dir, commit_message=...)
"""

import os
import time
import shutil
import subprocess
from pathlib import Path

import requests

# Config from environment
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GITHUB_USER = os.getenv("GITHUB_USER")  # your username or org

if not GITHUB_TOKEN or not GITHUB_USER:
    raise RuntimeError("Set GITHUB_TOKEN and GITHUB_USER environment variables")

# ------------------ repo creation ------------------
def create_github_repo(repo_name, description="Auto-generated by LLM deploy"):
    """
    Create a public repository under the authenticated user.
    Returns the JSON response from GitHub (repo metadata).
    """
    url = "https://api.github.com/user/repos"
    headers = {
        "Authorization": f"token {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }
    payload = {"name": repo_name, "description": description, "private": False, "auto_init": False}
    r = requests.post(url, headers=headers, json=payload, timeout=15)
    r.raise_for_status()
    return r.json()

# ------------------ push directory to new repo ------------------
def push_directory_to_repo(local_dir, repo_full_name):
    """
    Initialize git in local_dir, commit, and push to the given repo_full_name ("owner/repo").
    Returns the commit SHA of the pushed commit.
    """
    token = GITHUB_TOKEN
    remote = f"https://x-access-token:{token}@github.com/{repo_full_name}.git"
    cwd = str(Path(local_dir).resolve())

    # Basic git flow
    subprocess.run(["git", "init"], cwd=cwd, check=True)
    subprocess.run(["git", "checkout", "-b", "main"], cwd=cwd, check=True)
    subprocess.run(["git", "add", "."], cwd=cwd, check=True)
    subprocess.run(["git", "commit", "-m", "Initial commit (automated)"], cwd=cwd, check=True)
    subprocess.run(["git", "remote", "add", "origin", remote], cwd=cwd, check=True)
    subprocess.run(["git", "push", "-u", "origin", "main"], cwd=cwd, check=True)

    sha = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=cwd).decode().strip()
    return sha

# ------------------ enable / ensure GitHub Pages ------------------
def enable_pages(repo_full_name, poll_attempts=6, poll_delay=2):
    """
    Ensure GitHub Pages is enabled for repo_full_name ("owner/repo").
    Returns the pages HTML url (or a constructed fallback).
    Handles:
      - successful POST (201/202) then polls GET for html_url
      - 409 Conflict (Pages already exists) -> GET info
      - other HTTP errors are raised to the caller
    """
    api = f"https://api.github.com/repos/{repo_full_name}/pages"
    headers = {
        "Authorization": f"token {GITHUB_TOKEN}",
        "Accept": "application/vnd.github+json"
    }
    body = {"source": {"branch": "main", "path": "/"}}

    try:
        r = requests.post(api, headers=headers, json=body, timeout=15)
        # Successful creation may return 201 or 202
        if r.status_code in (201, 202):
            # Poll GET for html_url
            for _ in range(poll_attempts):
                info = requests.get(api, headers=headers, timeout=10)
                if info.status_code == 200:
                    html = info.json().get("html_url")
                    if html:
                        return html
                time.sleep(poll_delay)
            # fallback constructed URL if html_url not yet available
            owner, repo = repo_full_name.split("/", 1)
            return f"https://{GITHUB_USER}.github.io/{repo}/"

        # If Pages already exists, GitHub often returns 409
        elif r.status_code == 409:
            info = requests.get(api, headers=headers, timeout=10)
            if info.status_code == 200:
                html = info.json().get("html_url")
                if html:
                    return html
            owner, repo = repo_full_name.split("/", 1)
            return f"https://{GITHUB_USER}.github.io/{repo}/"

        else:
            # For other 4xx/5xx responses, raise so caller sees reason
            r.raise_for_status()

    except requests.exceptions.HTTPError:
        # Try GET as a last-ditch fallback before propagating error
        try:
            info = requests.get(api, headers=headers, timeout=10)
            if info.status_code == 200:
                html = info.json().get("html_url")
                if html:
                    return html
        except Exception:
            pass
        # re-raise original HTTPError
        raise

# ------------------ clone and update helpers for round-2 ------------------
def clone_repo_to_tmp(repo_full_name, tmpdir):
    """
    Clone repo to a temporary directory using token-auth remote.
    Returns path to the cloned directory.
    """
    token = GITHUB_TOKEN
    remote = f"https://x-access-token:{token}@github.com/{repo_full_name}.git"
    local = Path(tmpdir)
    if local.exists():
        shutil.rmtree(local)
    subprocess.run(["git", "clone", remote, str(local)], check=True)
    return str(local)

def update_repo_with_dir(clone_dir, source_dir, commit_message="Round 2 update (automated)"):
    """
    Copy files from source_dir into clone_dir (overwriting) then commit & push.
    Returns new commit SHA.
    NOTE: This is a simple overwrite strategy for small generated sites.
    """
    clone_path = Path(clone_dir)
    src_path = Path(source_dir)

    # copy files from source_dir into repo root (overwrite existing files)
    for item in src_path.iterdir():
        dest = clone_path / item.name
        if dest.exists():
            if dest.is_dir():
                shutil.rmtree(dest)
            else:
                dest.unlink()
        if item.is_dir():
            shutil.copytree(item, dest)
        else:
            shutil.copy2(item, dest)

    # commit & push
    subprocess.run(["git", "add", "."], cwd=str(clone_path), check=True)
    # make commit only if there are changes
    try:
        subprocess.run(["git", "commit", "-m", commit_message], cwd=str(clone_path), check=True)
    except subprocess.CalledProcessError:
        # git commit returns non-zero when there's nothing to commit; that's OK
        pass
    subprocess.run(["git", "push"], cwd=str(clone_path), check=True)
    sha = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=str(clone_path)).decode().strip()
    return sha
